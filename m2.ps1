<#

#[tmp reg (8bits)]   
000000 val_MEM[000]    (for even 29:0)                
001001 val_MEM[000+1]  (for odd 29:0)    
010010 val_MEM[001]    (for even 59:30)
011011 val_MEM[001+1]  (for odd 59:30)
100 100 zero
10100101 tmp_bit               
11000110 tmp_exe                   
111111 tmp_val                   

#[save reg (8bits)]
000000 addr_MEM[0]       
001001 addr_MEM[30]
010010 dx59
011011 validity_parity0 
100 100 validity_parity1 
101101 validity_parity2 
110110 validity_parity4
111111 validity_parity8

#[cmd]
0 000000 addr_MEM[0:59] (load word to 111 from MEM[])
1 001001 addr_MEM[0:59] (save word to MEM[] from 111)
2 010010 addr_cmd     (101 != 0 then go cmd)
3 011011$rd $rs       ($rd ^= $rs) 
4 100 100$rd [7:0]     ($rd += 1)
5 101101$rd [7:0]     ($rd << [7:0])
6110110$rd [7:0]     ($rd >> [7:0])
7 111111$rd $rs       ($rd &= $rs)

#>

# [program 2]
.data
    origin:  .word  29:0   # MEM[29:0]
    #     0 0 0 0 0 B A 9           (need to be filled)
    #     8 7 6 5 4 3 2 1           (need to be filled)
    w_parity: .word 59:30  # MEM[59:30]
    #     B A 9 8 7 6 5 e           (given)
    #     4 3 2 f 1 t o z           (given)

.text
.globl main

main:
    # initiate input data(origin) address
    100000000         # (000 = 0)
   
    # initiate output data(w_parity) address 
    100001111         # 001 += 7  (001 = 7)       (001 = 0 0 0 0 0 1 1 1)
    101001010         # 001 << 2  (001 = 28)      (001 = 0 0 0 1 1 1 0 0)
    100001010         # 001 += 2  (001 = 30)      (001 = 0 0 0 1 1 1 1 0)

    # escaping iteration data(010)
    100010111         # 001 += 7 (010 = 7)        (001 = 0 0 0 0 0 1 1 1) 
    101010011         # 001 << 3 (010 = 56)       (001 = 0 0 1 1 1 0 0 0)
    100010011         # 001 += 3 (010 = 59)       (001 = 0 0 1 1 1 0 1 1)

loop:
    # reset
    111011100         # reset validity_p0         (011 = 0)
    111100100         # reset validity_p1         (100 = 0) 
    111101100         # reset validity_p2         (101 = 0)
    111110100         # reset validity_p4         (110 = 0)
    111111100         # reset validity_p8         (111 = 0)
    111000100         # reset 000                 (000 = 0)
    111001100         # reset 001                 (001 = 0)
    111010100         # reset 010                 (010 = 0)
    111011100         # reset 011                 (011 = 0)
    111110100         # reset 110                 (110 = 0)
    111111100         # reset 111                 (111 = 0)

# CALCULATE PARITY BITS FROM EVENth MEMORY
    # value_of_even_MEM(001) -> tmp7 -> tmp2 
    000001             # load data MEM -> 111      (111 = b4 b3 b2 p4 b1 p2 p1 p0)
    011010111         # move 111 -> 010           (010 = b4 b3 b2 p4 b1 p2 p1 p0)

    # p0
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    111110010         # masking 010 -> 110        (110 = 0 0 0 0 0 0 0 p0)
    011011110         # p0    b            -> 011

    # p1
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110001         # 110 << 1                  (110 = 0 0 0 0 0 0 1 0)
    111110010         # masking 010 -> 110        (110 = 0 0 0 0 0 0 p1 0)
    110110001         # 110 >> 1                  (110 = 0 0 0 0 0 0 0 p1)
    011011110         # p01   b            -> 011
    011100110         # p 1   b            -> 100

    # p2
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110010         # 110 << 2                  (110 = 0 0 0 0 0 1 0 0)
    111110010         # masking 010 -> 110        (110 = 0 0 0 0 0 p2 0 0)
    110110010         # 110 >> 2                  (110 = 0 0 0 0 0 0 0 p2)
    011011110         # p012  b            -> 011
    011101110         # p  2  b            -> 101

    # b1
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110011         # 110 << 3                  (110 = 0 0 0 0 1 0 0 0)
    111110010         # masking 010 -> 110        (110 = 0 0 0 0 b1 0 0 0)
    110110011         # 110 >> 3                  (110 = 0 0 0 0 0 0 0 b1)
    011011110         # p012  b1           -> 011
    011100110         # p 1   b1           -> 100
    011101110         # p  2  b1           -> 101
 
    # p4
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110100         # 110 << 4                  (110 = 0 0 0 1 0 0 0 0)
    111110010         # masking 010 -> 110        (110 = 0 0 0 p4 0 0 0 0)
    110110100         # 110 >> 4                  (110 = 0 0 0 0 0 0 0 p4)
    011011110         # p0124 b1           -> 011
    011110110         # p   4 b            -> 110

    # b2
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110101         # 110 << 5                  (110 = 0 0 1 0 0 0 0 0)
    111110010         # masking 010 -> 110        (110 = 0 0 b2 0 0 0 0 0)
    110110101         # 110 >> 5                  (110 = 0 0 0 0 0 0 0 b2)
    011011110         # p0124 b12          -> 011
    011100110         # p 1   b12          -> 100
    011110110         # p   4 b 2          -> 110

    # b3
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110110         # 110 << 6                  (110 = 0 1 0 0 0 0 0 0)
    111110010         # masking 010 -> 110        (110 = 0 b3 0 0 0 0 0 0)
    110110110         # 110 >> 6                  (110 = 0 0 0 0 0 0 0 b3)
    011011110         # p0124 b123         -> 011
    011101110         # p  2  b1 3         -> 101
    011110110         # p   4 b 23         -> 110

    # b4
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110111         # 110 << 7                  (110 = 1 0 0 0 0 0 0 0)
    111110010         # masking 010 -> 110        (110 = b4 0 0 0 0 0 0 0)
    110110111         # 110 >> 7                  (110 = 0 0 0 0 0 0 0 b4)
    011011110         # p0124 b1234        -> 011
    011100110         # p 1   b12 4        -> 100
    011101110         # p  2  b1 34        -> 101
    011110110         # p   4 b 234        -> 110

    # reset
    111011100         # reset 011                 (011 = 0)
    111110100         # reset 110                 (110 = 0)
    111111100         # reset 111                 (111 = 0)

# CALCULATE PARITY BITS FROM ODDth MEMORY
    # value_of_odd_MEM(++001) -> tmp7 -> tmp3 
    100001001         # 001 += 1
    000001             # load data MEM -> 111      (111 = bB bA b9 b8 b7 b6 b5 p8)
    011011111         # move 111 -> 011           (011 = bB bA b9 b8 b7 b6 b5 p8)

    # p8
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    111110011         # masking 011 -> 110        (110 = 0 0 0 0 0 0 0 p8)
    011011110         # p01248b1234        -> 011
    011111110         # p    8             -> 111

    # b5
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110110         # 110 << 1                  (110 = 0 0 0 0 0 0 1 0)
    111110011         # masking 011 -> 110        (110 = 0 0 0 0 0 0 b5 0)
    110110110         # 110 >> 1                  (110 = 0 0 0 0 0 0 0 b5)
    011011110         # p01248b12345       -> 011
    011100110         # p 1   b12 45       -> 100
    011111110         # p    8b    5       -> 111

    # b6
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110010         # 110 << 2                  (110 = 0 0 0 0 0 1 0 0)
    111110011         # masking 011 -> 110        (110 = 0 0 0 0 0 b60 0)
    110110010         # 110 >> 2                  (110 = 0 0 0 0 0 0 0 b6)
    011011110         # p01248b123456      -> 011
    011101110         # p  2  b1 34 6      -> 101
    011111110         # p    8b    56      -> 111

    # b7
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110011         # 110 << 3                  (110 = 0 0 0 0 1 0 0 0)
    111110011         # masking 011 -> 110        (110 = 0 0 0 0 b7 0 0 0)
    110110011         # 110 >> 3                  (110 = 0 0 0 0 0 0 0 b7)
    011011110         # p01248b1234567     -> 011
    011100110         # p 1   b12 45 7     -> 100
    011101110         # p  2  b1 34 67     -> 101
    011111110         # p    8b    567     -> 111

    # b8
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110100         # 110 << 4                  (110 = 0 0 0 1 0 0 0 0)
    111110011         # masking 011 -> 110        (110 = 0 0 0 b8 0 0 0 0)
    110110100         # 110 >> 4                  (110 = 0 0 0 0 0 0 0 b8)
    011011110         # p01248b12345678    -> 011
    011110110         # p   4 b 234   8    -> 110
    011111110         # p    8b    5678    -> 111

    # b9
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110101         # 110 << 5                  (110 = 0 0 1 0 0 0 0 0)
    111110011         # masking 011 -> 110        (110 = 0 0 b9 0 0 0 0 0)
    110110101         # 110 >> 5                  (110 = 0 0 0 0 0 0 0 b9)
    011011110         # p01248b123456789   -> 011
    011100110         # p 1   b12 45 7 9   -> 100
    011110110         # p   4 b 234   89   -> 110
    011111110         # p    8b    56789   -> 111

    # bA
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110110         # 110 << 6                  (110 = 0 1 0 0 0 0 0 0)
    111110011         # masking 011 -> 110        (110 = 0 bA 0 0 0 0 0 0)
    110110110         # 110 >> 6                  (110 = 0 0 0 0 0 0 0 bA)
    011011110         # p01248b123456789A  -> 011
    011101110         # p  2  b1 34 67  A  -> 101
    011110110         # p   4 b 234   89A  -> 110
    011111110         # p    8b    56789A  -> 111

    # bB
    111110100         # reset 110                 (110 = 0) 
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101110111         # 110 << 7                  (110 = 1 0 0 0 0 0 0 0)
    111110011         # masking 011 -> 110        (110 = bB 0 0 0 0 0 0 0)
    110110111         # 110 >> 7                  (110 = 0 0 0 0 0 0 0 bB)
    011011110         # p01248b123456789AB -> 011
    011100110         # p1    b12 45 7 9 B -> 100
    011101110         # p2    b1 34 67  AB -> 101
    011110110         # p4    b 234   89AB -> 110
    011111110         # p8    b    56789AB  -> 111

    # reset 110
    111000100         # reset 000                 (000 = 0)
    111001100         # reset 001                 (001 = 0)
    111110100         # reset 110                 (110 = 0)
    111111100         # reset 111                 (111 = 0) 

# CASE BY CASE
    # bad - 1 BIT ERROR -> insert01
    # bad - MORE 2 BITS ERRORS -> insert10
    # good case NO ERROR -> insert00

    # To be good case                45673 eftoz
    # every validity_paritiy bit is supposed to Zero !!
    # Unless it is zero, that is false.
    # false -> not equals zero -> jump

# GO 1 BIT ERROR CASE
    # check 011 validity_parity0 
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101011         # 011 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 yesRecover     # IF 3 == F -> GO           // ????F (16 yesRecover cases)    
    # now every case in here -> ????T

# GO MORE 2 BITS ERRORS
    # check 111 validity_parity8 
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101111         # 111 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 noRecover      # IF 7 == F -> GO           // F???T (8 noRecover cases)
    # now every case in here -> T???T

    # check 110 validity_parity4 
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101110         # 1100 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 noRecover      # IF 6 == F -> GO           // TF??T (4 noRecover cases)
    # now every case in here -> TT??T

    # check 101 validity_parity2 
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101101         # 101 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 noRecover      # IF 5 == F -> GO           // TTF?T (2 noRecover cases)
    # now every case in here -> TTT?T

    # check 100 validity_parity1 
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 noRecover      # IF 4 == F -> GO           // TTTFT (1 noRecover case)
    # now every case in here -> TTTTT               (101 = 0 0 0 0 0 0 0 0)

# GO GOOD CASE NO ERROR
    # TTTTT : the only good case (no errer)
<#
    # good case:   
    # insert00     # good case -> [29:0] 중 첫 두자리 넣기
    # (011 = bB bA b9 b8 b7 b6 b5 p8)
    # (010 = b4 b3 b2 p4 b1 p2 p1 p0)
    # wanted t1 = ( 0  0  0  0  0 bB bA b9)
    # wanted t0 = (b8 b7 b6 b5 b4 b3 b2 b1)
#>
    # 시작비트 0 0 -> mem[s1]
    # 001 already 0 0 (as reset)

    # go to insetRestBits
    100101001         # 101 != 0                  (101 = 0 0 0 0 0 0 0 1)
    010 insetRestBits  # go to insetRestBits 

# bad - MORE 2 BITS ERRORS
noRecover:       
<#      
    # insert10     # bad case -> [29:0] 중 첫 두자리 넣기
    #            45673 eftoz 
    # ELSE                      TTTFT
    # ELSE                      TTF?T 
    # ELSE                      TF??T
    # ELSE                      F???T
    # (011 = bB bA b9 b8 b7 b6 b5 p8)
    # (010 = b4 b3 b2 p4 b1 p2 p1 p0)
    # no neeted t1 = ( 1  0  0  0  0 bB bA b9) -> only care first 1 bit.
    # no neeted t0 = (b8 b7 b6 b5 b4 b3 b2 b1) -> doesn't care at all.
    # directly put 111 -> addr_MEM[0] (000) 
#> 
    # s100e it is from jump                         (101 = 0 0 0 0 0 0 0 1)
    # 시작비트 1 0 -> mem[s1] (Don't care rest -> 바로 MEM으로 넣어버리기)
    100110001         # 110 = 1                   (110 = 0 0 0 0 0 0 0 1) 
    101110111         # 110 << 7                  (110 = 1 0 0 0 0 0 0 0) 
    011111110         # move 110 -> 111           (111 = 1 0 0 0 0 0 0 0) 
    # Don't care rest of all 000 bits 111 even-th 000 (skipped) !!!
    100000001         # 000 += 1 (even -> odd)    
    001000             # store data 111 -> MEM (only 1 0 . . . . . .)

    # Don't care rest of all 000 bits !!!
    # go to excapeLoop
    010 excapeLoop     # go to excapeLoop 

# bad - 1 BIT ERROR (16 CASES)
yesRecover:             
<#
    # insert01          # bad case -> [29:0] 중 첫 두자리 넣기
    # recover (011 = bB bA b9 b8 b7 b6 b5 p8)
    # recover (010 = b4 b3 b2 p4 b1 p2 p1 p0)
    # wanted t1 = ( 0  1  0  0  0 bB bA b9)
    # wanted t0 = (b8 b7 b6 b5 b4 b3 b2 b1)
#>
    # 시작비트 0 1 -> 001    
    100110001         # 110 = 1                   (110 = 0 0 0 0 0 0 0 1) 
    101110110         # 110 << 6                  (110 = 0 1 0 0 0 0 0 0) 
    011001110         # move 110 -> 001           (001 = 0 1 0 0 0 0 0 0) 
    111110100         # reset 110                 (110 = 0) 

    # find sole error bit -> recover at addr_MEM[30] (001) 
    #                                         45673 eftoz 
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101111         # 111 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 eIsFalse0      # IF 7 == F -> GO     T???F

    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101110         # 1100 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 fIsFalse0      # IF 6 == F -> GO     TT??F

    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101101         # 101 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 tIsFalse0      # IF 5 == F -> GO     TTT?F

    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 oIsFalse0      # IF 4 == F -> GO     TTTTF

# 1. TTTTF -> p0 : ~p0 at [59:30]
    # 110 = 1 1 1 1 1 1 1 ~p0
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)         
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 0 0 0 0 1)
    111110010         # 110 <- p0                 (110 = 0 0 0 0 0 0 0 p0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 1 1 1 1 ~p0)
    # (010 = b4 b3 b2 p4 b1 p2 p1 0) + 1
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101010         # 101 += 2                  (101 = 1 1 1 1 1 1 1 0) 
    111010101         # rest of 010               (010 = b4 b3 b2 p4 b1 p2 p1 0)
    100010001         # 010 += 1                  (010 = b4 b3 b2 p4 b1 p2 p1 1) 
    # 010 = b4 b3 b2 p4 b1 p2 p1 ~p0   
    111010110         # negation done             (010 = b4 b3 b2 p4 b1 p2 p1 ~p0)
    # go to rest of bit
    010 insetRestBits

oIsFalse0: # TTTFF
# 2. TTTFF -> p1 : recover ~p1 at [59:30] 
    # 110 = 1 1 1 1 1 1 ~p1 1
    100110010         # 110 += 2                  (110 = 0 0 0 0 0 0 1 0)         
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 0 0 0 1 0)
    111110010         # 110 <- p1                 (110 = 0 0 0 0 0 0 p1 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 1 1 1 ~p1 1)
    # (010 = b4 b3 b2 p4 b1 p2 0 p0) + 2
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101001         # 101 += 1                  (101 = 1 1 1 1 1 1 0 1) 
    111010101         # rest of 010               (010 = b4 b3 b2 p4 b1 p2 0 p0)
    100010010         # 010 += 2                  (010 = b4 b3 b2 p4 b1 p2 1 p0) 
    # 010 = b4 b3 b2 p4 b1 p2 ~p1 p0    
    111010110         # negation done             (010 = b4 b3 b2 p4 b1 p2 ~p1 p0)
    # go to rest of bit
    010 insetRestBits

tIsFalse0: # TTF?F
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 oIsFalse1      # IF 4 == F -> GO     TTFTF

# 3. TTFTF -> p2 : recover ~p2 at [59:30]
    # 110 = 1 1 1 1 1 ~p2 1 1
    100110100         # 110 += 4                  (110 = 0 0 0 0 0 1 0 0)         
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 0 0 1 0 0)
    111110010         # 110 <- p2                 (110 = 0 0 0 0 0 p2 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 1 1 ~p2 1 1)
    # (010 = b4 b3 b2 p4 b1 0 p1 p0) + 4
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101110         # 101 += 6                  (101 = 0 0 1 1 1 1 1 0) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 0 0 0) 
    100101011         # 101 += 1                  (101 = 1 1 1 1 1 0 1 1) 
    111010101         # rest of 010               (010 = b4 b3 b2 p4 b1 0 p1 p0)
    100010100         # 010 += 4                  (010 = b4 b3 b2 p4 b1 1 p1 p0) 
    # 010 = b4 b3 b2 p4 b1 ~p2 p1 p0    
    111010110         # negation done             (010 = b4 b3 b2 p4 b1 ~p2 p1 p0)
    # go to rest of bit
    010 insetRestBits

oIsFalse1: # TTFFF
# 4. TTFFF -> b1 : recover ~b1 at [59:30]    
    # 110 = 1 1 1 1 ~b1 1 1 1
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)    
    101110011         # 110 << 3                  (110 = 0 0 0 0 1 0 0 0)      
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 0 1 0 0 0)
    111110010         # 110 <- b1                 (110 = 0 0 0 0 b1 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 1 ~b1 1 1 1)
    # (010 = b4 b3 b2 p4 0 p2 p1 p0) + 8
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101101         # 101 += 5                  (101 = 0 0 1 1 1 1 0 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 0 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 0 1 1 1) 
    111010101         # rest of 010               (010 = b4 b3 b2 p4 0 p2 p1 p0)
    100010111         # 010 += 7                  accumulated 7
    100010001         # 010 += 1                  (010 = b4 b3 b2 p4 1 p2 p1 p0) 
    # 010 = b4 b3 b2 p4 ~b1 p2 p1 p0    
    111010110         # negation done             (010 = b4 b3 b2 p4 ~b1 p2 p1 p0)
    # go to rest of bit
    010 insetRestBits

fIsFalse0: # TF??F
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101101         # 101 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 tIsFalse1      # IF 5 == F -> GO     TFT?F

    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 oIsFalse2      # IF 4 == F -> GO     TFTTF

# 5. TFTTF -> p4 : recover ~p4 at [59:30]
    # 110 = 1 1 1 ~p4 1 1 1 1
    100110010         # 110 += 2                  (110 = 0 0 0 0 0 0 1 0)               
    101110011         # 110 << 3                  (110 = 0 0 0 1 0 0 0 0)    
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 1 0 0 0 0)
    111110010         # 110 <- p4                 (110 = 0 0 0 p4 0 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 ~p4 1 1 1 1)
    # (010 = b4 b3 b2 0 b1 p2 p1 p0) + 16
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101011         # 101 += 3                  (101 = 0 0 1 1 1 0 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 0 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 0 1 1 1 1) 
    111010101         # rest of 010               (010 = b4 b3 b2 0 b1 p2 p1 p0)
    100010111         # 010 += 7                  accumulated 7
    100010111         # 010 += 7                  accumulated 14
    100010010         # 010 += 2                  (010 = b4 b3 b2 1 b1 p2 p1 p0) 
    # 010 = b4 b3 b2 ~p4 b1 p2 p1 p0    
    111010110         # negation done             (010 = b4 b3 b2 ~p4 b1 p2 p1 p0)
    # go to rest of bit
    010 insetRestBits

oIsFalse2: # TFTFF
# 6. TFTFF -> b2 : recover ~b2 at [59:30]
    # 110 = 1 1 ~b2 1 1 1 1 1
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)           
    101110101         # 110 << 5                  (110 = 0 0 1 0 0 0 0 0)     
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 1 0 0 0 0 0)
    111110010         # 110 <- 011                (110 = 0 0 b2 0 0 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 ~b2 1 1 1 1 1)
    # (010 = b4 b3 0 p4 b1 p2 p1 p0) + 32
    111101100         # reset 101                 (101 = 0)
    100101110         # 101 += 6                  (101 = 0 0 0 0 0 1 1 0) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 0 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 0 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 0 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 0 1 1 1 1 1) 
    111010101         # rest of 010               (010 = b4 b3 0 p4 b1 p2 p1 p0)
    100010111         # 010 += 7                  accumulated 7
    100010111         # 010 += 7                  accumulated 14
    100010111         # 010 += 7                  accumulated 21
    100010111         # 010 += 7                  accumulated 28
    100010100         # 010 += 4                  (010 = b4 b3 1 p4 b1 p2 p1 p0) 
    # 010 = b4 b3 ~b2 p4 b1 p2 p1 p0    
    111010110         # negation done             (010 = b4 b3 ~b2 p4 b1 p2 p1 p0)
    # go to rest of bit
    010 insetRestBits

tIsFalse1: # TFF?F
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 oIsFalse3      # IF 4 == F -> GO     TFFTF

# 7. TFFTF -> b3 : recover ~b3 at [59:30]
    # 110 = 1 ~b3 1 1 1 1 1 1
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)           
    101110110         # 110 << 6                  (110 = 0 1 0 0 0 0 0 0)     
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 1 0 0 0 0 0 0)
    111110010         # 110 <- 011                (110 = 0 b3 0 0 0 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 ~b3 1 1 1 1 1 1)
    # (010 = b4 0 b2 p4 b1 p2 p1 p0) + 64
    111101100         # reset 101                 (101 = 0)
    100101101         # 101 += 5                  (101 = 0 0 0 0 0 1 0 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 0 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 0 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 0 1 1 1 1 0 0) 
    100101001         # 101 += 1                  (101 = 1 0 1 1 1 1 1 1) 
    111010101         # rest of 010               (010 = b4 0 b2 p4 b1 p2 p1 p0)
    100010111         # 010 += 7                  accumulated 7
    100010111         # 010 += 7                  accumulated 14
    100010111         # 010 += 7                  accumulated 21
    100010111         # 010 += 7                  accumulated 28
    100010111         # 010 += 7                  accumulated 35
    100010111         # 010 += 7                  accumulated 42
    100010111         # 010 += 7                  accumulated 49
    100010111         # 010 += 7                  accumulated 56
    100010111         # 010 += 7                  accumulated 63
    100010001         # 010 += 1                  (010 = b4 1 b2 p4 b1 p2 p1 p0) 
    # 010 = b4 ~b3 b2 p4 b1 p2 p1 p0    
    111010110         # negation done             (010 = b4 ~b3 b2 p4 b1 p2 p1 p0)
    # go to rest of bit
    010 insetRestBits

oIsFalse3: # TFFFF        
# 8. TFFFF -> b4 : recover ~b4 at [59:30]# 110 = ~b4 1 1 1 1 1 1 1
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)           
    101110111         # 110 << 7                  (110 = 1 0 0 0 0 0 0 0)     
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 1 0 0 0 0 0 0 0)
    111110010         # 110 <- 011                (110 = b4 0 0 0 0 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101001         # 101 << 1                  (101 = 0 1 1 1 1 1 1 0) 
    100101001         # 101 += 1                  (101 = 0 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = ~b4 1 1 1 1 1 1 1)
    # (010 = 0 b3 b2 p4 b1 p2 p1 p0) + 128
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101001         # 101 << 1                  (101 = 0 1 1 1 1 1 1 0) 
    100101001         # 101 += 1                  (101 = 0 1 1 1 1 1 1 1) 
    111010101         # rest of 010               (010 = 0 b3 b2 p4 b1 p2 p1 p0)
    100010111         # 010 += 7                  accumulated 7
    100010111         # 010 += 7                  accumulated 14
    100010111         # 010 += 7                  accumulated 21
    100010111         # 010 += 7                  accumulated 28
    100010111         # 010 += 7                  accumulated 35
    100010111         # 010 += 7                  accumulated 42
    100010111         # 010 += 7                  accumulated 49
    100010111         # 010 += 7                  accumulated 56
    100010111         # 010 += 7                  accumulated 63
    100010111         # 010 += 7                  accumulated 70
    100010111         # 010 += 7                  accumulated 77
    100010111         # 010 += 7                  accumulated 84
    100010111         # 010 += 7                  accumulated 91
    100010111         # 010 += 7                  accumulated 98
    100010111         # 010 += 7                  accumulated 105
    100010111         # 010 += 7                  accumulated 112
    100010111         # 010 += 7                  accumulated 119
    100010111         # 010 += 7                  accumulated 126
    100010010         # 010 += 2                  (010 = 1 b3 b2 p4 b1 p2 p1 p0) 
    # 010 = ~b4 b3 b2 p4 b1 p2 p1 p0    
    111010110         # negation done             (010 = ~b4 b3 b2 p4 b1 p2 p1 p0)
    # go to rest of bit
    010 insetRestBits

eIsFalse0: # F???F
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101110         # 1100 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 fIsFalse1      # IF 6 == F -> GO     FT??F

    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101101         # 101 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 tIsFalse2      # IF 5 == F -> GO     FTT?F

    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 oIsFalse4      # IF 4 == F -> GO     FTTTF

# 9. FTTTF -> p8 : recover ~p8 at [59:30]
    # 110 = 1 1 1 1 1 1 1 ~p8
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)         
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 0 0 0 0 1)
    111110011         # 110 <- p8                 (110 = 0 0 0 0 0 0 0 p8)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 1 1 1 1 ~p8)
    # (011 = bB bA b9 b8 b7 b6 b5 0) + 1
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101010         # 101 += 2                  (101 = 1 1 1 1 1 1 1 0) 
    111011101         # rest of 011               (011 = bB bA b9 b8 b7 b6 b5 0)
    100011001         # 011 += 1                  (011 = bB bA b9 b8 b7 b6 b5 1) 
    # 011 = bB bA b9 b8 b7 b6 b5 ~p8  
    111011110         # negation done             (011 = bB bA b9 b8 b7 b6 b5 ~p8)
    # go to rest of bit
    010 insetRestBits

oIsFalse4: # FTTFF
# 10. FTTFF -> b5 : recover ~b5 at [59:30]
    # 110 = 1 1 1 1 1 1 ~b5 1
    100110010         # 110 += 2                  (110 = 0 0 0 0 0 0 1 0)         
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 0 0 0 1 0)
    111110011         # 110 <- b5                 (110 = 0 0 0 0 0 0 b5 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 1 1 1 ~b5 1)
    # (011 = bB bA b9 b8 b7 b60 p8) + 2
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101001         # 101 += 1                  (101 = 1 1 1 1 1 1 0 1) 
    111011101         # rest of 011               (011 = bB bA b9 b8 b7 b60 p8)
    100011010         # 011 += 2                  (011 = bB bA b9 b8 b7 b61 p8) 
    # 011 = bB bA b9 b8 b7 b6 ~b5 p8    
    111011110         # negation done             (011 = bB bA b9 b8 b7 b6 ~b5 p8)
    # go to rest of bit
    010 insetRestBits

tIsFalse2:                       FTF?F
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 oIsFalse5      # IF 4 == F -> GO     FTFTF

# 11. FTFTF -> b6 : recover ~b6 at [59:30]
    # 110 = 1 1 1 1 1 ~b61 1
    100110100         # 110 += 4                  (110 = 0 0 0 0 0 1 0 0)         
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 0 0 1 0 0)
    111110011         # 110 <- b6                 (110 = 0 0 0 0 0 b60 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 1 1 ~b61 1)
    # (011 = bB bA b9 b8 b7 0 b5 p8) + 4
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101110         # 101 += 6                  (101 = 0 0 1 1 1 1 1 0) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 0 0 0) 
    100101011         # 101 += 1                  (101 = 1 1 1 1 1 0 1 1) 
    111011101         # rest of 011               (011 = bB bA b9 b8 b7 0 b5 p8)
    100011100         # 011 += 4                  (011 = bB bA b9 b8 b7 1 b5 p8) 
    # 011 = bB bA b9 b8 b7 ~b6 b5 p8    
    111011110         # negation done             (011 = bB bA b9 b8 b7 ~b6 b5 p8)
    # go to rest of bit
    010 insetRestBits

oIsFalse5: # FTFFF
# 12. FTFFF -> b7 : recover ~b7 at [59:30]
    # 110 = 1 1 1 1 ~b7 1 1 1
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)    
    101110011         # 110 << 3                  (110 = 0 0 0 0 1 0 0 0)      
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 0 1 0 0 0)
    111110011         # 110 <- b7                 (110 = 0 0 0 0 b7 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 1 ~b7 1 1 1)
    # (011 = bB bA b9 b8 0 b6 b5 p8) + 8
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101101         # 101 += 5                  (101 = 0 0 1 1 1 1 0 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 0 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 0 1 1 1) 
    111011101         # rest of 011               (011 = bB bA b9 b8 0 b6 b5 p8)
    100011111         # 011 += 7                  accumulated 7
    100011001         # 011 += 1                  (011 = bB bA b9 b8 1 b6 b5 p8) 
    # 011 = bB bA b9 b8 ~b7 b6 b5 p8    
    111011110         # negation done             (011 = bB bA b9 b8 ~b7 b6 b5 p8)
    # go to rest of bit
    010 insetRestBits

fIsFalse1: # FF??F
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101101         # 101 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 tIsFalse3      # IF 5 == F -> GO     FFT?F

    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 oIsFalse6      # IF 4 == F -> GO     FFTTF

# 13. FFTTF -> b8 : recover ~b8 at [59:30]
    # 110 = 1 1 1 ~b8 1 1 1 1
    100110010         # 110 += 2                  (110 = 0 0 0 0 0 0 1 0)               
    101110011         # 110 << 3                  (110 = 0 0 0 1 0 0 0 0)    
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 0 1 0 0 0 0)
    111110011         # 110 <- b8                 (110 = 0 0 0 b8 0 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 1 ~b8 1 1 1 1)
    # (011 = bB bA b9 0 b7 b6 b5 p8) + 16
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101011         # 101 += 3                  (101 = 0 0 1 1 1 0 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 0 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 0 1 1 1 1) 
    111011101         # rest of 011               (011 = bB bA b9 0 b7 b6 b5 p8)
    100011111         # 011 += 7                  accumulated 7
    100011111         # 011 += 7                  accumulated 14
    100011010         # 011 += 2                  (011 = bB bA b9 1 b7 b6 b5 p8) 
    # 011 = bB bA b9 ~b8 b7 b6 b5 p8    
    111011110         # negation done             (011 = bB bA b9 ~b8 b7 b6 b5 p8)
    # go to rest of bit
    010 insetRestBits

oIsFalse6: # FFTFF
# 14. FFTFF -> b9 : recover ~b9 at [59:30]
    # 110 = 1 1 ~b9 1 1 1 1 1
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)           
    101110101         # 110 << 5                  (110 = 0 0 1 0 0 0 0 0)     
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 0 1 0 0 0 0 0)
    111110011         # 110 <- 011                (110 = 0 0 b9 0 0 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 1 ~b9 1 1 1 1 1)
    # (011 = bB bA 0 b8 b7 b6 b5 p8) + 32
    111101100         # reset 101                 (101 = 0)
    100101110         # 101 += 6                  (101 = 0 0 0 0 0 1 1 0) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 0 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 0 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 0 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 0 1 1 1 1 1) 
    111011101         # rest of 011               (011 = bB bA 0 b8 b7 b6 b5 p8)
    100011111         # 011 += 7                  accumulated 7
    100011111         # 011 += 7                  accumulated 14
    100011111         # 011 += 7                  accumulated 21
    100011111         # 011 += 7                  accumulated 28
    100011100         # 011 += 4                  (011 = bB bA 1 b8 b7 b6 b5 p8) 
    # 011 = bB bA ~b9 b8 b7 b6 b5 p8    
    111011110         # negation done             (011 = bB bA ~b9 b8 b7 b6 b5 p8)
    # go to rest of bit
    010 insetRestBits

tIsFalse3: # FFF?F
    111101100         # reset 101                 (101 = 0)
    100101001         # masking bit               (101 = 0 0 0 0 0 0 0 1)
    111101100         # 100 0 digit -> 101        (101 = 0 0 0 0 0 0 0 ?)
    010 IsFalse7       # IF 4 == F -> GO     FFFTF

# 15. FFFTF -> bA : recover ~bA at [59:30]
    # 110 = 1 ~bA 1 1 1 1 1 1
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)           
    101110110         # 110 << 6                  (110 = 0 1 0 0 0 0 0 0)     
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 0 1 0 0 0 0 0 0)
    111110011         # 110 <- 011                (110 = 0 bA 0 0 0 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 1 1 1 1 1 0 0) 
    100101011         # 101 += 3                  (101 = 1 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = 1 ~bA 1 1 1 1 1 1)
    # (011 = bB 0 b9 b8 b7 b6 b5 p8) + 64
    111101100         # reset 101                 (101 = 0)
    100101101         # 101 += 5                  (101 = 0 0 0 0 0 1 0 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 0 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 0 1 1 1 1) 
    101101010         # 101 << 2                  (101 = 1 0 1 1 1 1 0 0) 
    100101001         # 101 += 1                  (101 = 1 0 1 1 1 1 1 1) 
    111011101         # rest of 011               (011 = bB 0 b9 b8 b7 b6 b5 p8)
    100011111         # 011 += 7                  accumulated 7
    100011111         # 011 += 7                  accumulated 14
    100011111         # 011 += 7                  accumulated 21
    100011111         # 011 += 7                  accumulated 28
    100011111         # 011 += 7                  accumulated 35
    100011111         # 011 += 7                  accumulated 42
    100011111         # 011 += 7                  accumulated 49
    100011111         # 011 += 7                  accumulated 56
    100011111         # 011 += 7                  accumulated 63
    100011001         # 011 += 1                  (011 = bB 1 b9 b8 b7 b6 b5 p8) 
    # 011 = bB ~bA b9 b8 b7 b6 b5 p8    
    111011110         # negation done             (011 = bB ~bA b9 b8 b7 b6 b5 p8)
    # go to rest of bit
    010 insetRestBits

oIsFalse7: # FFFFF
# 16. FFFFF -> bB : recover ~bB at [59:30] 
    # 110 = ~bB 1 1 1 1 1 1 1
    100110001         # 110 += 1                  (110 = 0 0 0 0 0 0 0 1)           
    101110111         # 110 << 7                  (110 = 1 0 0 0 0 0 0 0)     
    111101100         # reset 101                 (101 = 0)  
    011101110         # 101 <- 110                (101 = 1 0 0 0 0 0 0 0)
    111110011         # 110 <- 011                (110 = bB 0 0 0 0 0 0 0)   
    111101100         # reset 101                 (101 = 0)  
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101001         # 101 << 1                  (101 = 0 1 1 1 1 1 1 0) 
    100101001         # 101 += 1                  (101 = 0 1 1 1 1 1 1 1) 
    011110101         # nagation 110              (110 = ~bB 1 1 1 1 1 1 1)
    # (011 = 0 bA b9 b8 b7 b6 b5 p8) + 128
    111101100         # reset 101                 (101 = 0)
    100101111         # 101 += 7                  (101 = 0 0 0 0 0 1 1 1) 
    101101011         # 101 << 3                  (101 = 0 0 1 1 1 0 0 0) 
    100101111         # 101 += 7                  (101 = 0 0 1 1 1 1 1 1) 
    101101001         # 101 << 1                  (101 = 0 1 1 1 1 1 1 0) 
    100101001         # 101 += 1                  (101 = 0 1 1 1 1 1 1 1) 
    111011101         # rest of 011               (011 = 0 bA b9 b8 b7 b6 b5 p8)
    100011111         # 011 += 7                  accumulated 7
    100011111         # 011 += 7                  accumulated 14
    100011111         # 011 += 7                  accumulated 21
    100011111         # 011 += 7                  accumulated 28
    100011111         # 011 += 7                  accumulated 35
    100011111         # 011 += 7                  accumulated 42
    100011111         # 011 += 7                  accumulated 49
    100011111         # 011 += 7                  accumulated 56
    100011111         # 011 += 7                  accumulated 63
    100011111         # 011 += 7                  accumulated 70
    100011111         # 011 += 7                  accumulated 77
    100011111         # 011 += 7                  accumulated 84
    100011111         # 011 += 7                  accumulated 91
    100011111         # 011 += 7                  accumulated 98
    100011111         # 011 += 7                  accumulated 105
    100011111         # 011 += 7                  accumulated 112
    100011111         # 011 += 7                  accumulated 119
    100011111         # 011 += 7                  accumulated 126
    100011010         # 011 += 2                  (011 = 1 bA b9 b8 b7 b6 b5 p8) 
    # 011 = ~bB bA b9 b8 b7 b6 b5 p8    
    111011110         # negation done             (011 = ~bB bA b9 b8 b7 b6 b5 p8)
    # go to rest of bit
    010 insetRestBits

# INSERT REST OF BITS
insetRestBits:#[29:0] 중 첫 두자리 제외하고 복원된 데이터로 나머지 넣기
    # insert rest of bit
    # (011 = bB bA b9 b8 b7 b6 b5 p8)
    # (010 = b4 b3 b2 p4 b1 p2 p1 p0)
    # (001 = 0 1 0 0 0 0 0 0) 
    # (000 = 0) 
    # wanted t1 = ( 0  1  0  0  0 bB bA b9)
    # wanted t0 = (b8 b7 b6 b5 b4 b3 b2 b1)

    # t0,t1 완성후 s0으로 넣기
    # t3 -> 3개 뽑아 t1 제작 
    111110100         # reset 110                 (110 = 0) 
    100110111         # 110 += 7                  (110 = 0 0 0 0 0 1 1 1) 
    101110101         # 110 << 5                  (110 = 1 1 1 0 0 0 0 0) 
    111110011         # masking 011 -> 110        (110 = bB bA b9 0 0 0 0 0)
    110110101         # 110 >> 5                  (110 = 0 0 0 0 0 bB bA b9) 
    011001110         # move 110 -> 001           (001 = 0 0 0 0 0 bB bA b9) 

    # t3 -> 4개 뽑아 t0 일부제작 
    111110100         # reset 110                 (110 = 0) 
    100110111         # 110 += 7                  (110 = 0 0 0 0 0 1 1 1)
    101110110         # 110 << 1                  (110 = 0 0 0 0 1 1 1 0)  
    100110001         # 110 += 1                  (110 = 0 0 0 0 1 1 1 1)  
    101110110         # 110 << 1                  (110 = 0 0 0 1 1 1 1 0)   
    111110011         # masking 011 -> 110        (110 = 0 0 0 b8 b7 b6 b5 0)
    101110011         # 110 << 3                  (110 = b8 b7 b6 b5 0 0 0 0) 
    011000110         # move 110 -> 000           (000 = b8 b7 b6 b5 0 0 0 0) 

    # t2 -> 4개 뽑아 t0 완성
    111110100         # reset 110                 (110 = 0) 
    100110111         # 110 += 7                  (110 = 0 0 0 0 0 1 1 1)
    101110101         # 110 << 5                  (110 = 1 1 1 0 0 0 0 0)   
    111110010         # masking 010 -> 110        (110 = b4 b3 b2 0 0 0 0 0)
    100111001         # 111 += 1                  (110 = 0 0 0 0 0 0 0 1) 
    101111011         # 111 << 3                  (111 = 0 0 0 0 1 0 0 0)
    111111010         # masking 010 -> 111        (111 = 0 0 0 0 b1 0 0 0)
    101111111         # 111 << 1                  (111 = 0 0 0 b1 0 0 0 0)
    011110111         # move 111 -> 110           (110 = b4 b3 b2 b1 0 0 0 0)
    110110100         # 110 >> 4                  (110 = 0 0 0 0 b4 b3 b2 b1)
    011000110         # move 110 -> 000           (000 = b8 b7 b6 b5 b4 b3 b2 b1) 
 
    # t0 -> mem[s0] // even
    111111100         # reset 111                 (111 = 0)
    011111000         # move 000 -> 111           (111 = b8 b7 b6 b5 b4 b3 b2 b1) 
    001000
    100000001         # 000 += 1
 
    # t1 -> mem[s0] // odd
    111111100         # reset 111                 (111 = 0)
    011111001         # move 001 -> 111           (111 = 0 0 0 0 0 bB bA b9) 
    001000

# ESCAPE LOOP
excapeLoop:
    # check escape loop
    111110100         # reset 110                 (110 = 0) 
    011110000         # move 000 -> 110           (110 = addr_MEM[0]) 
    011110010         # 110 ^= 010                // addr_MEM[0]^59 == 0 ?
    100000001         # 000 += 1
    100001001         # 001 += 1
    111101100         # reset 101                 (101 = 0)
    011101110         # move 110 -> 101
    010 loop    

exit:
    li $v0, 10         # exit program syscall         # 10
    syscall 