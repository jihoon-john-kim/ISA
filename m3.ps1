<#
[tmp reg (8bits)]   
000000 val_MEM[000/ += 1]    (for half 31:0)                
001001 val_MEM[000]  (for full 30:0 111 31)    
010010 
011011 
100100 zero
101101 tmp_bit               
110110 tmp_exe                   
111111 tmp_val                   

[save reg (8bits)]
000000 addr_MEM[0]       
001001 pattern
010010 dx31
011011 mem[33] (~128)
100100 mem[34] (~32)
101101 mem[35] (~252)
110110 tmp[34] (0000~1111)
111111

[cmd]
0 000000 addr_MEM[0:59] (load word to 111 from MEM[])
1 001001 addr_MEM[0:59] (save word to MEM[] from 111)
2 010010 addr_cmd     (101's LSB != 0 then go cmd)
3 011011 $rd $rs       ($rd ^= $rs) 
4 100100 $rd [7:0]     ($rd += 1)
5 101101 $rd [7:0]     ($rd << [7:0])
6 110110 $rd [7:0]     ($rd >> [7:0])
7 111111 $rd $rs       ($rd &= $rs)

#>

# [program 3] 
.data
    origin:  .word  29:0         # MEM[29:0]
    w_parity: .word 59:30        # MEM[59:30]

.text
.globl main

# bring pattern from MEM[32] [7:3]
# (- 7 6 5 4 3 - -)
# MEM[0:31] 패턴 분석 -> 4번씩 확인     v:누산  #: 중 1개만 인정          33(~128) 34(~32) 35(~252)
# loop:
# mem[0] (0_8 0_7 0_6 0_5 0_4 0_3 0_2 0_1) 
#                                        -> 0_8 0_7 0_6 0_5 0_4           v1        1         v1 
#                                        -> 0_7 0_6 0_5 0_4 0_3           v2        1         v2
#                                        -> 0_6 0_5 0_4 0_3 0_2           v3        1         v3
#                                        -> 0_5 0_4 0_3 0_2 0_1           v4        1         v4
#        (0_4 0_3 0_2 0_1 1_8 1_7 1_6 1_5) 
#                                        -> 0_4 0_3 0_2 0_1 1_8                               v5
#                                        -> 0_3 0_2 0_1 1_8 1_7                               v6
#                                        -> 0_2 0_1 1_8 1_7 1_6                               v7
#                                        -> 0_1 1_8 1_7 1_6 1_5                               v8
# mem[1] (1_8 1_7 1_6 1_5 1_4 1_3 1_2 1_1) 
#                                        -> 1_8 1_7 1_6 1_5 1_4           v5        2         v9
#                                        -> 1_7 1_6 1_5 1_4 1_3           v6        2         v10
#
#                  ...                             ...                                ...
#
#
#        (30_4 30_3 30_2 30_1 31_8 31_7 31_6 31_5)
#                       -> 30_4 30_3 30_2 30_1 31_8                        v245
#                               -> 30_3 30_2 30_1 31_8 31_7                        v246
#                               -> 30_2 30_1 31_8 31_7 31_6                        v247
#                               -> 30_1 31_8 31_7 31_6 31_5                        v248
# <loop end>
# 
# mem[31] (31_8 31_7 31_6 31_5 31_4 31_3 31_2 31_1) 
#                        -> 31_8 31_7 31_6 31_5 31_4      v125      32        v249
#                                -> 31_7 31_6 31_5 31_4 31_3      v126      32        v250
#                                -> 31_6 31_5 31_4 31_3 31_2      v127      32        v251
#                                -> 31_5 31_4 31_3 31_2 31_1      v128      32        v252

main:
    # initiate input data(pattern) address
    100000001         # 000 += 1  (000 = 1)   (000 = 0 0 0 0 0 0 0 1)
    101000101         # 000 << 5  (000 = 32)  (000 = 0 0 1 0 0 0 0 0)

    # escaping iteration data(010)
    100010111         # 010 += 7  (010 = 7)   (010 = 0 0 0 0 0 1 1 1)
    101010010         # 010 << 2  (010 = 28)  (010 = 0 0 0 1 1 1 0 0)
    100010011         # 010 += 3  (010 = 31)  (010 = 0 0 0 1 1 1 1 1)
    
    # bring the pattern
    000000             # load data MEM -> 111  (111 =  b8 b7 b6 b5 b4 b3 b2 b1) : MEM[32]
    101111001         # 111 << 1              (111 =  b7 b6 b5 b4 b3 b2 b1 0)
    110111011         # 111 >> 3              (111 =  0 0 0 b7 b6 b5 b4 b3)
    111001111         # 001 <- 111            (001 =  0 0 0 b7 b6 b5 b4 b3) : pattern
    111000100         # 000 reset             (000 = 0 0 0 0 0 0 0 0)
    

loop:
    # reset
    111000100         # reset 000 (000 = 0 0 0 0 0 0 0 0)
    111001100         # reset 001 (000 = 0 0 0 0 0 0 0 0)
    111101100         # reset 101 (101 = 0 0 0 0 0 0 0 0)
    111111100         # reset 111 (111 = 0 0 0 0 0 0 0 0)

    # value_of_full_MEM(000) -> tmp7 -> tmp0 
    000000             # load data MEM -> 111  (111 = b8 b7 b6 b5 b4 b3 b2 b1)
    011000111         # move 111 -> 000       (000 = b8 b7 b6 b5 b4 b3 b2 b1)

    # value_of_half_MEM(000/) -> /tmp7 -> tmp1 
    101111100         # 111 << 4              (111 = b4 b3 b2 b1 0 0 0 0)
    011001111         # move 111 -> 001       (001 = b4 b3 b2 b1 0 0 0 0)

    # value_of_half_MEM(/ += 1) -> tmp7/ -> tmp1
    100000001         # 000 += 1
    000000             # load data MEM -> 111  (111 = b8 b7 b6 b5 b4 b3 b2 b1)
    110111100         # 111 >> 4              (111 = 0 0 0 0 b8 b7 b6 b5)
    011001111         # move 111 -> 001       (001 = b4 b3 b2 b1 b8 b7 b6 b5)

  # 000 count -> 011 mem[33] (~128)
  #           -> 110 tmp[34] -> 100 mem[34] (~32)
  #           -> 101 mem[35] (~252)

# [000 count -> 011 mem[33] (~128)]             (000 = b8 b7 b6 b5 b4 b3 b2 b1)
# CHECK 0 0 0 b5 b4 b3 b2 b1
    011101000         # move 000 -> 101       (101 = b8 b7 b6 b5 b4 b3 b2 b1)
    101101011         # 101 << 3              (101 = b5 b4 b3 b2 b1 0 0 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b5 b4 b3 b2 b1) 
    011101001         # if 101 == 001 -> 0    (101 = 0 0 0 ? ? ? ? ?)
    010 skip1          
    #  101 == 001 -> 0  # found the pattern
    100011001          # 011 += 1
    100101001          # 101 += 1
    100110001          # 110 += 1
skip1:

# CHECK 0 0 b6 b5 b4 b3 b2 0
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0)
    011101000         # move 000 -> 101       (101 = b8 b7 b6 b5 b4 b3 b2 b1)
    101101010         # 101 << 2              (101 = b6 b5 b4 b3 b2 b1 0 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b6 b5 b4 b3 b2)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip2
    #  101 == 001 -> 0  # found the pattern
    100011001         # 011 += 1
    100101001         # 101 += 1
    100110001         # 110 += 1
skip2:

# CHECK 0 b7 b6 b5 b4 b3 0 0
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0) 
    011101000         # move 000 -> 101       (101 = b8 b7 b6 b5 b4 b3 b2 b1)
    101101001         # 101 << 1              (101 = b7 b6 b5 b4 b3 b2 b1 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b7 b6 b5 b4 b3)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip3
    #  101 == 001 -> 0  # found the pattern
    100011001          # 011 += 1
    100101001          # 101 += 1
    100110001          # 110 += 1
skip3:

# CHECK b8 b7 b6 b5 b4 0 0 0 
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0)
    011101000         # move 000 -> 101       (101 = b8 b7 b6 b5 b4 b3 b2 b1)
    110101011         # 101 >> 3              (101 = 0 0 0 b8 b7 b6 b5 b4)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip4
    #  101 == 001 -> 0  # found the pattern
    100011001          # 011 += 1
    100101001          # 101 += 1
    100110001          # 110 += 1
skip4:

# [if 110 > 0 -> 100 mem[34]++ (~32)]
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0)
    011101110         # move 110 -> 101       (101 = 0 0 0 0 0 ? ? ?)
    010 skip5          
    # 110 == 0          # no found              (101 = 0 0 0 0 0 0 0 0)
    100101001         # masking bit           (101 = 0 0 0 0 0 0 0 1)
    010 skip6
skip5: # found at least one pattern
    # 110 != 0          # found at least one pattern
    111110100         # reset 110             (110 = 0 0 0 0 0 0 0 0)
    100100001         # 110 += 1
    111100100         # 100 reset
skip6: # no found

# [001 count -> 101 += 1 mem[35] (~252)]        (001 = b4 b3 b2 b1 b8 b7 b6 b5)
# CHECK 0 0 0 b1 b8 b7 b6 b5
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0)
    011101001         # move 001 -> 101       (101 = b4 b3 b2 b1 b8 b7 b6 b5)
    101101011         # 101 << 3              (101 = b1 b8 b7 b6 b5 0 0 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b1 b8 b7 b6 b5)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip7  
    #  101 == 001 -> 0  # found the pattern
    100101001         # 101 += 1
skip7:    

    # 0 0 0 b2 b1 b8 b7 b6
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0) 
    011101001         # move 001 -> 101       (101 = b4 b3 b2 b1 b8 b7 b6 b5)
    101101010         # 101 << 2              (101 = b2 b1 b8 b7 b6 b5 0 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b2 b1 b8 b7 b6)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip8   
    #  101 == 001 -> 0  # found the pattern
    100101001         # 101 += 1
skip8:

    # 0 0 0 b3 b2 b1 b8 b7
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0) 
    011101001         # move 001 -> 101       (101 = b4 b3 b2 b1 b8 b7 b6 b5)
    101101001         # 101 << 1              (101 = b3 b2 b1 b8 b7 b6 b5 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b3 b2 b1 b8 b7)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip9
    #  101 == 001 -> 0  # found the pattern
    100101001          # 101 += 1
skip9:

    # 0 0 0 b4 b3 b2 b1 b8
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0) 
    011101001         # move 001 -> 101       (101 = b4 b3 b2 b1 b8 b7 b6 b5)
    110101011         # 101 >> 3              (101 = 0 0 0 b4 b3 b2 b1 b8)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip10
    #  101 == 001 -> 0  # found the pattern
    100101001          # 101 += 1
skip10:

    # escape loop
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0) 
    011101000         # move 000 -> 101       (101 = addr_MEM[31])
    011101010         #                       (101 = addr_MEM[31]^29)
    010 loop           # go back to loop
    # 101 == 29 : 000 == 010

# <loop end>
    # reset
    111000100         # reset 000 (000 = 0 0 0 0 0 0 0 0)
    111101100         # reset 101 (101 = 0 0 0 0 0 0 0 0)
    111111100         # reset 111 (111 = 0 0 0 0 0 0 0 0)

    # last value_of_full_MEM[31] -> tmp7 -> tmp0     (000 = 31)
    000000             # load data last MEM to 111 (111 = b8 b7 b6 b5 b4 b3 b2 b1)
    011000111         # move 111 -> 000       (000 = b8 b7 b6 b5 b4 b3 b2 b1)
    
    # 0 0 0 b5 b4 b3 b2 b1
    011101001         # move 001 -> 101       (101 = b8 b7 b6 b5 b4 b3 b2 b1)
    101101011         # 101 << 3              (101 = b5 b4 b3 b2 b1 0 0 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b5 b4 b3 b2 b1)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip11 
    #  101 == 001 -> 0  # found the pattern
    100011001          # 011 += 1
    100101001          # 101 += 1
    100110001          # 110 += 1
skip11:
    
    # 0 0 0 b6 b5 b4 b3 b2
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0)
    011101001         # move 001 -> 101       (101 = b8 b7 b6 b5 b4 b3 b2 b1)
    101101010         # 101 << 2              (101 = b6 b5 b4 b3 b2 b1 0 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b6 b5 b4 b3 b2)
    010 skip12  
    #  101 == 001 -> 0  # found the pattern
    100011001          # 011 += 1
    100101001          # 101 += 1
    100110001          # 110 += 1
skip12:
    
    # 0 0 0 b7 b6 b5 b4 b3
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0) 
    011101001         # move 001 -> 101       (101 = b8 b7 b6 b5 b4 b3 b2 b1)
    101101001         # 101 << 1              (101 = b7 b6 b5 b4 b3 b2 b1 0)
    110101011         # 101 >> 3              (101 = 0 0 0 b7 b6 b5 b4 b3)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip13   
    #  101 == 001 -> 0  # found the pattern
    100011001          # 011 += 1
    100101001          # 101 += 1
    100110001          # 110 += 1
skip13:
    
    # 0 0 0 b8 b7 b6 b5 b4 
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0)
    011101001         # move 001 -> 101       (101 = b8 b7 b6 b5 b4 b3 b2 b1)
    110101011         # 101 >> 3              (101 = 0 0 0 b8 b7 b6 b5 b4)
    011101001         # 101 == 001 -> 0       (101 = 0 0 0 ? ? ? ? ?)
    010 skip14 
    #  101 == 001 -> 0  # found the pattern
    100011001          # 011 += 1
    100101001          # 101 += 1
    100110001          # 110 += 1
skip14:

# [if 110 > 0 -> 100 mem[34]++ (~32)]
    111101100         # reset 101             (101 = 0 0 0 0 0 0 0 0)
    011101110         # move 110 -> 101       (101 = 0 0 0 0 0 ? ? ?)
    010 skip15          
    # 110 == 0          # no found              (101 = 0 0 0 0 0 0 0 0)
    100101001         # masking bit           (101 = 0 0 0 0 0 0 0 1)
    010 skip16
skip15: # found at least one pattern
    # 110 != 0          # found at least one pattern
    111110100         # reset 110             (110 = 0 0 0 0 0 0 0 0)
    100100001         # 110 += 1
    111100100         # 100 reset
skip16: # no found

  # output
    # MEM[33]
    100000010         # 000 += 2              (000 = 33)
    111111100         # reset 111             (111 = 0 0 0 0 0 0 0 0)
    011111011         # move 011 -> 111       (011 = (~128))
    001000              # store data MEM[33]

    # MEM[34]
    100000001         # 000 += 1              (000 = 34)
    111111100         # reset 111             (111 = 0 0 0 0 0 0 0 0)
    011111100         # move 100 -> 111       (100 = (~32))
    001000              # store data MEM[34]

    # MEM[35]
    100000001         # 000 += 1              (000 = 35)
    111111100         # reset 111             (111 = 0 0 0 0 0 0 0 0)
    011111101         # move 101 -> 111       (101 = (~252))
    001000              # store data MEM[35]

exit:
    li $v0, 10          # exit program syscall# 10
    syscall 











